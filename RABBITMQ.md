

# 1. MQ使用场景

    流量消峰：使用消息队列做缓冲，把一秒内下的订单分散成一段时间来处理
    应用解耦：
        以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合
        调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于
        消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在
        这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流
        系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。
    异步处理

# 2. MQ选择

    kafka：日志，大厂
    rocketmq：金融，双11，支付
    rabbitmq：中小公司

# 3.4大核心概念

    生产者
    交换机
    队列
    消费者
    
    每个生产者和mq会建立一个连接，连接里面通过多个信道进行消息投递
    一个borker里面包含多个虚拟主机，每个虚拟主机包含多个交换机+队列
    每个消费者和mq建立一个连接，连接通过多个信道对消息进行消费

# 4.rabbitmq工作模式

    hello：rabbitmq-hello：
        最简单的消息投递与消费，没有申明式交换机，使用默认交换机
        一个生产，一个线程消费
    work queues：rabbitmq-hello：
        一个生产，多个消费者轮询进行消费

# 5.消息应答

    1.自动应答
    2.手动应答：防止程序执行一半宕机，导致消费失败，一般使用此种方式进行
        A.Channel.basicAck(用于肯定确认)RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了，一般都使用单个 应答，而不使用批量应答
            Channel.basicAck(deliveryTag,true);第一个参数为为当前收到的消息，第二个参数表示是否开启批量应答：
                true 代表批量应答 channel 上未应答的消息
                    比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时
                    5-8 的这些还未应答的消息都会被确认收到消息应答
                false 同上面相比
                    只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答
        B.Channel.basicNack(用于否定确认)
        C.Channel.basicReject(用于否定确认)与 Channel.basicNack 相比少一个参数,不处理该消息了直接拒绝，可以将其丢弃了
    3.消息自动重新入队
        未ack的消息会重新入队


# 6.
