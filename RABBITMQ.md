

# 1. MQ使用场景

    流量消峰：使用消息队列做缓冲，把一秒内下的订单分散成一段时间来处理
    应用解耦：
        以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合
        调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于
        消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在
        这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流
        系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。
    异步处理

# 2. MQ选择

    kafka：日志，大厂
    rocketmq：金融，双11，支付
    rabbitmq：中小公司

# 3.4大核心概念

    生产者
    交换机
    队列
    消费者
    
    每个生产者和mq会建立一个连接，连接里面通过多个信道进行消息投递
    一个borker里面包含多个虚拟主机，每个虚拟主机包含多个交换机+队列
    每个消费者和mq建立一个连接，连接通过多个信道对消息进行消费

# 4.rabbitmq工作模式

    hello：rabbitmq-hello：
        最简单的消息投递与消费，没有申明式交换机，使用默认交换机
        一个生产，一个线程消费
    work queues：rabbitmq-hello：
        一个生产，多个消费者轮询进行消费
    fanout：广播模式 - 扇出交换机
        一个生产：多个消费，每个消费者要将所有的消息都消费一遍
    Direct exchange：- 直接交换机
        相当于广播模式，又加了routingkey进行区分，消费者可以指定队列进行消费，若指定同一个则可以同时消费
        【如果绑定关系写错了，并且已经测试过，一定记得去界面把绑定关系删除，否则可能会造成消费错误】
    topic：主题模式 - 主题交换机:利用routingkey的动态匹配包含了直接模式和广播模式
        直接交换机和扇出交换机只能路由一个队列，为解决这个问题，引入主题交换机
            发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单
            词列表，以点号分隔开。这些单词可以是任意单词，比如说："stock.usd.nyse", "nyse.vmw",
            "quick.orange.rabbit".这种类型的。当然这个单词列表最多不能超过 255 个字节。
            在这个规则列表中，其中有两个替换符是大家需要注意的
            *(星号)可以代替一个单词
            #(井号)可以替代零个或多个单词
        当队列绑定关系是下列这种情况时需要引起注意
            当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了
            如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了
        
                

# 5.消息应答

    1.自动应答
    2.手动应答：防止程序执行一半宕机，导致消费失败，一般使用此种方式进行
        A.Channel.basicAck(用于肯定确认)RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了，一般都使用单个 应答，而不使用批量应答
            Channel.basicAck(deliveryTag,true);第一个参数为为当前收到的消息，第二个参数表示是否开启批量应答：
                true 代表批量应答 channel 上未应答的消息
                    比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时
                    5-8 的这些还未应答的消息都会被确认收到消息应答
                false 同上面相比
                    只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答
        B.Channel.basicNack(用于否定确认)
        C.Channel.basicReject(用于否定确认)与 Channel.basicNack 相比少一个参数,不处理该消息了直接拒绝，可以将其丢弃了
    3.消息自动重新入队
        未ack的消息会重新入队
    4.持久化队列：
        如果已经存在没有持久化的队列，那么直接创建就会报错，需要先删除再创建
        //第三个参数 让消息实现持久化，将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是
            //这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没
            //有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要
            //更强有力的持久化策略，参考后边课件发布确认章节
                channel.basicPublish("", TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes("UTF-8"));
    5.预取值
        当 prefetchCount设置为1的时候为不公平分发，
        >=1的时候为预取值，等同于线程池一样，例如prefetchCount=5，表示最多能预分5条数据，等待应答，若其中一条ack了，则此时还能在进一条继续等待。
        int prefetchCount = 2;
        channel.basicQos(prefetchCount);
    6.发布确认：-如何保证消息一定是存储成功的
        1.设置要求队列必须持久化
            pers.li.$3messageAsk.Task02
                //第二个参数修改为true，使消息队列持久化，如果队列存在，则需要先删除再执行该代码
                channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null);
        2.设置队列中的消息必须持久化
            pers.li.$3messageAsk.Task02
                //第三个参数
                channel.basicPublish("", TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes("UTF-8"));
        3.发布确认，需要等待mq回执说明消息已经成功保存到磁盘
            开启发布确认：
                try (Channel channel = RabbitMqUtils.getChannel()) {
                //开启确认发布
                channel.confirmSelect();
            发布确认的三种方式：
                单个确认发布-同步确认：
                批量确认发布:
                    优点：上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地
                            提高吞吐量
                    缺点：当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，
                        以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布
                异步确认发布：速度最快，回调实现，并且可以确定哪个投递失败，常用
    7.交换机的作用
            生产者生产的消息从不会直接发送到队列
            生产者只能将消息发送到交换机(exchange)
            它接收来自生产者的消息，另一方面将它们推入队列
            交换机也会依据他自身的类型，来选择是将消息推到特定队列，还是多个队列还是丢弃消息
        默认的交换机：仅支持一个消费者
        交换机类型：
            直接(direct)： 路由
            主题(topic) ：
            标题(headers) ：
            扇出(fanout)：发布订阅
            无名类型：默认类型：代码为空串
                channel.basicPublish("", queueName, null, message.getBytes());
                消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话         
    8.临时队列：
        创建临时队列的方式如下:String queueName = channel.queueDeclare().getQueue();
    9.绑定：
        什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队
        列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定

# 6.死信队列

    定义：最终都没有被消费的消息，就会进入死信队列
    进入死信队列的情况：
        1.消息TTL过期（指的是消息的过期时间，在一定时间未被消费就会进入死信队列）
        2.消息队列填满，无法再次添加消息，也会进入死信队列 
            1.消息生产者代码去掉 TTL 属性
            2.C1 消费者修改以下代码(启动之后关闭该消费者 模拟其接收不到消息)
            3.C2 消费者代码不变(启动 C2 消费者)
            注意此时需要把原先队列删除 因为参数改变了
        3.消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false
    应用场景：
        1.为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中
        2.用户在商城下单成功并点击去支付后在指定时间未支付时自动失效

# 7.延迟队列
    
    1.原理：存放需要在指定时间被处理的元素的队列-利用的就是消息ttl过期，基于死信队列实现
    2.场景：
        1.订单在十分钟之内未支付则自动取消
        2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。
        3.用户注册成功后，如果三天内没有登陆则进行短信提醒。
        4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。
        5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议
    3.启动测试：
        http://localhost:8080/ttl/sendMsg/hhh
        http://localhost:8080/ttl/sendExpirationMsg/你好 1/20000
        http://localhost:8080/ttl/sendExpirationMsg/你好 2/2000
        第一个消费完才消费第二个，不符合预期
    4.缺点：
        RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列，
        如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行
        基于死信队列的会由此问题，可通过插件解决。
    5.解决：使用mq插件实现延迟队列
        1.官网下载：https://www.rabbitmq.com/community-pligins.html
        2.然后解压到rabbitmq的插件目录下
        3.进入安装目录下的plugins目录，执行下面命令使插件生效，然后重启rabbitmq
            /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins
            rabbitmq-plugins enable rabbitmq_delayed_message_exchange
        4.测试符合预期
            http://localhost:8080/ttl/sendDelayMsg/你好 1/20000
            http://localhost:8080/ttl/sendDelayMsg/你好 2/2000
            第二个先消费，符合预期
